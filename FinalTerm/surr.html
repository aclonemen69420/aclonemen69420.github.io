<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>1132934 -FinalTerm</title>
    <style>
        :root {
            --board-color: #e3bc7a;
            --line-color: #2b2b2b;
            --black-stone: #1a1a1a;
            --white-stone: #f0f0f0;
            --bg-gradient: linear-gradient(135deg, #1e272e, #485460);
            --shadow-color: rgba(0,0,0,0.4);
        }

        body {
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            background: var(--bg-gradient);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: white;
            user-select: none;
            touch-action: manipulation;
        }

        h1 {
            margin: 15px 0 10px;
            font-weight: 300;
            letter-spacing: 2px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        /* --- éŠæˆ²è³‡è¨Šé¢æ¿ --- */
        .game-info {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 25px;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            backdrop-filter: blur(5px);
        }

        .player-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px 15px;
            border-radius: 20px;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 2px solid transparent;
            opacity: 0.6;
            transform: scale(0.95);
        }

        .player-card.active {
            background: rgba(255, 255, 255, 0.1);
            border-color: #f1c40f;
            opacity: 1;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.2);
        }

        .stone-icon {
            width: 22px; height: 22px;
            border-radius: 50%;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }
        .stone-icon.black { background: var(--black-stone); border: 1px solid #555; }
        .stone-icon.white { background: var(--white-stone); border: 1px solid #ccc; }

        /* --- æ£‹ç›¤å€åŸŸ --- */
        .board-wrapper {
            padding: 15px;
            background: #d4a558;
            border-radius: 5px;
            box-shadow: 
                0 3px 0 #8b5a2b, 
                0 20px 40px rgba(0,0,0,0.6);
            position: relative;
        }

        #go-board {
            display: grid;
            grid-template-columns: repeat(9, 45px); /* æ¡Œé¢ç‰ˆå°ºå¯¸ */
            grid-template-rows: repeat(9, 45px);
            position: relative;
            /* æœ¨ç´‹æè³ª */
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.5' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");
        }

        .intersection {
            width: 45px;
            height: 45px;
            position: relative;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* æ ¼ç·š */
        .intersection::before { /* æ©«ç·š */
            content: ''; position: absolute;
            height: 1px; width: 100%;
            background: var(--line-color);
            top: 50%; left: 0; transform: translateY(-50%);
            z-index: 0;
        }
        .intersection::after { /* ç›´ç·š */
            content: ''; position: absolute;
            width: 1px; height: 100%;
            background: var(--line-color);
            left: 50%; top: 0; transform: translateX(-50%);
            z-index: 0;
        }

        /* é‚Šç·£ä¿®æ­£ */
        .intersection.left::before { left: 50%; width: 50%; }
        .intersection.right::before { width: 50%; }
        .intersection.top::after { top: 50%; height: 50%; }
        .intersection.bottom::after { height: 50%; }

        /* æ˜Ÿä½é» */
        .star-dot {
            width: 8px; height: 8px;
            background: #000;
            border-radius: 50%;
            position: absolute; z-index: 1;
        }

        /* é è¦½è½å­æ•ˆæœ */
        .intersection:not(.has-stone):hover::after {
            content: ''; position: absolute;
            width: 20px; height: 20px;
            background: rgba(0,0,0,0.15);
            border-radius: 50%;
            z-index: 2;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .scoring-mode .intersection:hover::after { display: none; }

        /* --- æ£‹å­æ¨£å¼ --- */
        .stone {
            width: 38px; height: 38px;
            border-radius: 50%;
            position: absolute; z-index: 10;
            box-shadow: 2px 2px 4px var(--shadow-color);
            transform: scale(1);
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1); /* å½ˆæ€§å‹•ç•« */
        }
        /* è½å­å‹•ç•« */
        .stone.place-anim {
            animation: placeStone 0.2s ease-out;
        }
        @keyframes placeStone {
            from { transform: scale(1.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .stone.black {
            background: radial-gradient(circle at 35% 35%, #555 5%, #1a1a1a 90%);
        }
        .stone.white {
            background: radial-gradient(circle at 35% 35%, #fff 5%, #d1d1d1 90%);
        }

        /* æœ€å¾Œä¸€æ‰‹æ¨™è¨˜ (ç´…è‰²åœ“ç’°) */
        .stone.last-move::before {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 12px; height: 12px;
            border: 2px solid #e74c3c;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* æå­å‹•ç•« (ç¸®å°æ¶ˆå¤±) */
        .stone.capturing {
            animation: captureAnim 0.4s forwards ease-in;
            pointer-events: none;
        }
        @keyframes captureAnim {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; filter: brightness(2); }
            100% { transform: scale(0); opacity: 0; }
        }

        /* å«åƒè­¦å‘Š (ç´…è‰²å‘¼å¸ç‡ˆ) */
        .stone.atari {
            box-shadow: 0 0 0 2px #e74c3c, 0 0 10px #e74c3c;
            animation: pulseAtari 1.5s infinite;
        }
        @keyframes pulseAtari {
            0% { box-shadow: 0 0 0 2px rgba(231, 76, 60, 0.4); }
            50% { box-shadow: 0 0 0 3px rgba(231, 76, 60, 1), 0 0 12px rgba(231, 76, 60, 0.6); }
            100% { box-shadow: 0 0 0 2px rgba(231, 76, 60, 0.4); }
        }

        /* æ­»å­æ¨™è¨˜ (é»ç›®æ™‚) */
        .stone.dead { opacity: 0.4; filter: grayscale(1); }
        .stone.dead::after {
            content: 'âœ•'; color: red; font-size: 24px; font-weight: bold;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }

        /* --- æ§åˆ¶å€ --- */
        .controls {
            margin-top: 25px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            width: 100%;
            max-width: 400px;
        }
        
        .control-row {
            grid-column: 1 / -1;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        button {
            padding: 12px 20px;
            font-size: 15px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: bold;
            color: white;
            transition: transform 0.1s, filter 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
        }
        button:active { transform: translateY(2px); box-shadow: 0 2px 0 rgba(0,0,0,0.2); }
        button:disabled { background: #7f8c8d; opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }

        .btn-pass { background: #e67e22; }
        .btn-undo { background: #3498db; }
        .btn-reset { background: #e74c3c; }
        .btn-calc { background: #2ecc71; grid-column: 1 / -1; }
        
        /* AI é–‹é—œæŒ‰éˆ• */
        .btn-ai { 
            background: #8e44ad; 
            width: 100%;
        }
        .btn-ai.off { background: #95a5a6; }

        #status-message {
            height: 24px; margin-top: 15px;
            color: #f1c40f; font-weight: bold;
            opacity: 0; transition: opacity 0.3s;
        }

        /* é ˜åœ°é¡¯ç¤º */
        .territory {
            width: 12px; height: 12px;
            position: absolute; z-index: 5;
            transform: rotate(45deg);
        }
        .territory.black { background: #000; box-shadow: 0 0 2px #fff; }
        .territory.white { background: #fff; box-shadow: 0 0 2px #000; }

        /* RWD æ‰‹æ©Ÿé©é… */
        @media (max-width: 500px) {
            #go-board { grid-template-columns: repeat(9, 38px); grid-template-rows: repeat(9, 38px); }
            .intersection { width: 38px; height: 38px; }
            .stone { width: 32px; height: 32px; }
        }

        /* çµç®—å½ˆçª— */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; justify-content: center; align-items: center;
            z-index: 100; opacity: 0; pointer-events: none;
            transition: opacity 0.3s;
        }
        .modal-overlay.active { opacity: 1; pointer-events: auto; }
        .modal-content {
            background: #2d3436; padding: 30px; border-radius: 15px;
            text-align: center; border: 1px solid #e3bc7a; width: 85%; max-width: 320px;
        }
    </style>
</head>
<body>

    <h1>ä¹è·¯åœæ£‹</h1>

    <div class="game-info">
        <div class="player-card active" id="card-black">
            <div class="stone-icon black"></div>
            <div>é»‘æ£‹ <span id="info-black">(ç©å®¶)</span></div>
            <div style="font-size:0.8em; color:#aaa; margin-left:5px;">æ: <span id="cap-black">0</span></div>
        </div>
        <div class="player-card" id="card-white">
            <div class="stone-icon white"></div>
            <div>ç™½æ£‹ <span id="info-white">(AI)</span></div>
            <div style="font-size:0.8em; color:#aaa; margin-left:5px;">æ: <span id="cap-white">0</span></div>
        </div>
    </div>

    <div class="board-wrapper">
        <div id="go-board"></div>
    </div>

    <div id="status-message">æç¤ºè¨Šæ¯</div>

    <div class="controls">
        <button class="btn-ai" id="btn-ai" onclick="game.toggleAI()">
            <span>ğŸ¤– AI: é–‹å•Ÿ</span>
        </button>
        <button class="btn-undo" onclick="game.undo()" id="btn-undo">â†© æ‚”æ£‹</button>
        
        <div class="control-row">
            <button class="btn-pass" onclick="game.pass()" id="btn-pass">è®“å­ (Pass)</button>
            <button class="btn-reset" onclick="location.reload()">â†º é‡ä¾†</button>
        </div>
        
        <button class="btn-calc" onclick="game.finishScoring()" id="btn-calc" style="display:none">âœ… ç¢ºèªæ­»å­ä¸¦è¨ˆç®—</button>
    </div>

    <div class="modal-overlay" id="result-modal">
        <div class="modal-content">
            <h2 style="color:#e3bc7a; margin:0 0 15px;">å°å±€çµæœ</h2>
            <div style="display:flex; justify-content:space-between; margin-bottom:10px; font-size:1.1em;">
                <span>é»‘æ£‹ (åœ°+å­)</span> <strong id="final-black">0</strong>
            </div>
            <div style="display:flex; justify-content:space-between; margin-bottom:10px; font-size:1.1em;">
                <span>ç™½æ£‹ (åœ°+å­+è²¼)</span> <strong id="final-white">0</strong>
            </div>
            <div style="color:#7f8c8d; font-size:0.9em; margin-bottom:20px;">(è²¼ç›® 5.5 ç›®)</div>
            <div id="winner-text" style="font-size:1.8em; font-weight:bold; color:#f1c40f; margin-bottom:20px;"></div>
            <button class="btn-undo" style="width:100%" onclick="location.reload()">å†ä¾†ä¸€å±€</button>
        </div>
    </div>

    <script>
        // éŸ³æ•ˆç”¢ç”Ÿå™¨ (ä½¿ç”¨ Web Audio APIï¼Œé¿å…å¤–éƒ¨è³‡æºåŠ è¼‰å•é¡Œ)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'move') { // è½å­è²ï¼šçŸ­ä¿ƒä½éŸ³
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.15);
            } else if (type === 'capture') { // æå­è²ï¼šæ¸…è„†é«˜éŸ³
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.start(); osc.stop(audioCtx.currentTime + 0.2);
            } else if (type === 'atari') { // å«åƒè²ï¼šé›™éŸ³è­¦ç¤º
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.start(); osc.stop(audioCtx.currentTime + 0.2);
            }
        }

        class GoGame {
            constructor() {
                this.size = 9;
                this.resetData();
                this.initUI();
                this.updateStatusUI();
            }

            resetData() {
                this.board = Array(this.size).fill().map(() => Array(this.size).fill(0));
                this.currentPlayer = 1; // 1=é»‘, 2=ç™½
                this.prisoners = { 1: 0, 2: 0 };
                this.history = [];
                this.koPoint = null;
                this.passes = 0;
                this.gamePhase = 'playing'; 
                this.deadStones = new Set();
                this.komi = 5.5;
                this.aiEnabled = true;
                this.isProcessing = false; // é˜²æ­¢é€£é»
                this.lastMove = null;
                this.atariPoints = new Set(); // è¨˜éŒ„å“ªäº›é»è™•æ–¼å«åƒç‹€æ…‹
            }

            initUI() {
                const boardEl = document.getElementById('go-board');
                boardEl.innerHTML = '';
                const stars = ['2,2', '6,2', '4,4', '2,6', '6,6'];

                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'intersection';
                        if (r === 0) cell.classList.add('top');
                        if (r === this.size - 1) cell.classList.add('bottom');
                        if (c === 0) cell.classList.add('left');
                        if (c === this.size - 1) cell.classList.add('right');

                        if (stars.includes(r + ',' + c)) {
                            const dot = document.createElement('div');
                            dot.className = 'star-dot';
                            cell.appendChild(dot);
                        }

                        cell.dataset.r = r;
                        cell.dataset.c = c;
                        cell.onclick = () => this.handleClick(r, c);
                        boardEl.appendChild(cell);
                    }
                }
            }

            async handleClick(r, c) {
                if (this.isProcessing) return;
                
                if (this.gamePhase === 'playing') {
                    // å¦‚æœæ˜¯äººé¡å›åˆ (é»‘æ£‹) æˆ– AIé—œé–‰æ™‚çš„ä»»ä¸€æ–¹
                    const isHumanTurn = (this.currentPlayer === 1) || (!this.aiEnabled);
                    if (isHumanTurn) {
                        await this.attemptMove(r, c);
                    }
                } else if (this.gamePhase === 'scoring') {
                    this.toggleDeadStone(r, c);
                }
            }

            async attemptMove(r, c) {
                if (this.board[r][c] !== 0) return;
                
                this.isProcessing = true;
                const success = await this.playMove(r, c);
                
                if (success) {
                    playTone('move');
                    // AI å›åˆ
                    if (this.aiEnabled && this.gamePhase === 'playing' && this.currentPlayer === 2) {
                        setTimeout(() => this.aiMove(), 500);
                    } else {
                        this.isProcessing = false;
                    }
                } else {
                    this.isProcessing = false;
                }
            }

            async playMove(r, c) {
                // 1. è¦å‰‡æª¢æŸ¥
                if (this.koPoint && this.koPoint.r === r && this.koPoint.c === c) {
                    this.showMessage("â›” ç¦è‘—é»ï¼šæ‰“åŠ« (Ko)");
                    return false;
                }

                // 2. æ¨¡æ“¬èˆ‡è‡ªæ®ºæª¢æŸ¥
                const tempBoard = JSON.parse(JSON.stringify(this.board));
                tempBoard[r][c] = this.currentPlayer;
                const opponent = 3 - this.currentPlayer;
                const captures = this.checkCaptures(r, c, opponent, tempBoard); // æª¢æŸ¥æ˜¯å¦åƒæ‰å°æ–¹
                const myLiberties = this.getGroupLiberties(r, c, tempBoard); // æª¢æŸ¥è‡ªå·±æ°£

                if (myLiberties === 0 && captures.length === 0) {
                    this.showMessage("â›” ç¦è‘—é»ï¼šè‡ªæ®º");
                    return false;
                }

                // 3. åŸ·è¡Œç§»å‹• (æ›´æ–°æ•¸æ“š)
                // å­˜æª”æ‚”æ£‹
                this.history.push({
                    board: JSON.parse(JSON.stringify(this.board)),
                    prisoners: {...this.prisoners},
                    ko: this.koPoint,
                    turn: this.currentPlayer,
                    lastMove: this.lastMove
                });

                this.board[r][c] = this.currentPlayer;
                this.lastMove = {r, c};
                this.passes = 0;

                // 4. UI æ”¾ç½®æ£‹å­
                this.renderStone(r, c, this.currentPlayer);

                // 5. è™•ç†æå­ (å‹•ç•« + æ•¸æ“šç§»é™¤)
                if (captures.length > 0) {
                    await this.animateCaptures(captures); // ç­‰å¾…å‹•ç•«çµæŸ
                    playTone('capture');
                    this.showMessage(`ğŸ’¥ æåƒ ${captures.length} å­!`);
                    this.prisoners[this.currentPlayer] += captures.length;
                    
                    // æ‰“åŠ«åˆ¤å®š
                    if (captures.length === 1 && myLiberties === 0 && this.getGroupSize(r, c, this.board) === 1) {
                        this.koPoint = captures[0];
                    } else {
                        this.koPoint = null;
                    }
                } else {
                    this.koPoint = null;
                }

                // 6. æ›æ‰‹èˆ‡ç‹€æ…‹æ›´æ–°
                this.currentPlayer = opponent;
                
                // 7. è¨ˆç®—å«åƒ (Atari)
                this.checkAtari();
                
                this.updateStatusUI();
                return true;
            }

            renderStone(r, c, color) {
                const cell = document.querySelector(`.intersection[data-r="${r}"][data-c="${c}"]`);
                const stone = document.createElement('div');
                stone.className = `stone ${color === 1 ? 'black' : 'white'} place-anim`;
                cell.appendChild(stone);
                cell.classList.add('has-stone');
            }

            async animateCaptures(stones) {
                // 1. æ¨™è¨˜æ‰€æœ‰è¦ç§»é™¤çš„æ£‹å­é€²è¡Œå‹•ç•«
                stones.forEach(s => {
                    const cell = document.querySelector(`.intersection[data-r="${s.r}"][data-c="${s.c}"]`);
                    const stone = cell.querySelector('.stone');
                    if (stone) stone.classList.add('capturing');
                });

                // 2. ç­‰å¾…å‹•ç•«æ™‚é–“
                await new Promise(resolve => setTimeout(resolve, 400));

                // 3. çœŸæ­£å¾æ•¸æ“šå’Œç•«é¢ç§»é™¤
                stones.forEach(s => {
                    this.board[s.r][s.c] = 0;
                    const cell = document.querySelector(`.intersection[data-r="${s.r}"][data-c="${s.c}"]`);
                    cell.innerHTML = ''; // æ¸…é™¤æ£‹å­
                    cell.classList.remove('has-stone');
                    // è£œå›å¯èƒ½è¢«æ¸…æ‰çš„æ˜Ÿä½é»
                    const stars = ['2,2', '6,2', '4,4', '2,6', '6,6'];
                    if (stars.includes(s.r + ',' + s.c)) {
                        const dot = document.createElement('div');
                        dot.className = 'star-dot';
                        cell.appendChild(dot);
                    }
                });
            }

            checkAtari() {
                // æª¢æŸ¥ç•¶å‰åŸ·å­æ–¹ (å‰›æ›æ‰‹ï¼Œæ‰€ä»¥æ˜¯ check å°æ–¹æ˜¯å¦è¢«å«åƒ)
                // ä¹Ÿè¦æª¢æŸ¥è‡ªå·±æ˜¯å¦è™•æ–¼å«åƒ (å°‘è¦‹ä½†å¯èƒ½)
                this.atariPoints.clear();
                
                // æƒæå…¨ç›¤æ‰€æœ‰æ£‹ä¸²
                const visited = new Set();
                let atariSoundTriggered = false;

                for(let r=0; r<this.size; r++){
                    for(let c=0; c<this.size; c++){
                        if(this.board[r][c] !== 0 && !visited.has(`${r},${c}`)){
                            const group = this.getGroup(r, c, this.board);
                            // æ¨™è¨˜é€™ä¸²å·²æª¢æŸ¥
                            group.stones.forEach(s => visited.add(`${s.r},${s.c}`));

                            if (group.liberties === 1) {
                                // é€™ä¸€ä¸²å‰©ä¸€æ°£ï¼Œæ¨™è¨˜æ‰€æœ‰æ£‹å­ç‚º Atari
                                group.stones.forEach(s => this.atariPoints.add(`${s.r},${s.c}`));
                                
                                // å¦‚æœæ˜¯è¢«å«åƒçš„æ˜¯å‰›è¼ªåˆ°ä¸‹çš„é€™ä¸€æ–¹ (currentPlayer)ï¼Œç™¼å‡ºè­¦å‘ŠéŸ³æ•ˆ
                                if (this.board[r][c] === this.currentPlayer && !atariSoundTriggered) {
                                    playTone('atari');
                                    atariSoundTriggered = true;
                                }
                            }
                        }
                    }
                }
            }

            // --- AI é‚è¼¯ ---
            async aiMove() {
                if (this.gamePhase !== 'playing') return;

                const candidates = [];
                for(let r=0; r<this.size; r++) {
                    for(let c=0; c<this.size; c++) {
                        if(this.board[r][c] === 0) {
                            if (!this.isSuicideOrKo(r, c)) {
                                candidates.push({r, c, score: this.evaluate(r, c)});
                            }
                        }
                    }
                }

                if (candidates.length === 0) {
                    this.pass();
                    this.isProcessing = false;
                    return;
                }

                candidates.sort((a, b) => b.score - a.score);
                // å¢åŠ éš¨æ©Ÿæ€§ï¼šå‰3é¸1
                const topMoves = candidates.slice(0, 3);
                const pick = topMoves[Math.floor(Math.random() * topMoves.length)];
                
                await this.playMove(pick.r, pick.c);
                this.isProcessing = false;
            }

            isSuicideOrKo(r, c) {
                if (this.koPoint && this.koPoint.r === r && this.koPoint.c === c) return true;
                // ç°¡æ˜“è‡ªæ®ºåˆ¤æ–·ï¼šä¸‹å­å¾Œç„¡æ°£ä¸”æ²’åƒåˆ°äºº
                const tempBoard = JSON.parse(JSON.stringify(this.board));
                tempBoard[r][c] = this.currentPlayer;
                const captures = this.checkCaptures(r, c, 3-this.currentPlayer, tempBoard);
                const liberties = this.getGroupLiberties(r, c, tempBoard);
                return (liberties === 0 && captures.length === 0);
            }

            evaluate(r, c) {
                let score = Math.random() * 5; 
                // 1. é‡‘è§’éŠ€é‚Šè‰è‚šçš®
                if ((r===2||r===6) && (c===2||c===6)) score += 15;
                if (r===4 && c===4) score += 10;
                if (r===0 || r===8 || c===0 || c===8) score -= 2;

                // 2. æ”»å®ˆåˆ¤æ–·
                const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
                let nearEnemy = 0;
                let nearFriend = 0;
                
                dirs.forEach(([dr, dc]) => {
                    const nr = r+dr, nc = c+dc;
                    if (this.isOnBoard(nr, nc)) {
                        if (this.board[nr][nc] === 1) nearEnemy++;
                        if (this.board[nr][nc] === 2) nearFriend++;
                    }
                });

                if (nearEnemy > 0) score += 5; // æ¥è§¸æˆ°
                if (nearFriend > 0) score += 3; // é€£æ¥
                
                // 3. é¿å…è‡ªå·±å¡«è‡ªå·±çš„çœ¼ (ç°¡å–®åˆ¤å®š)
                if (nearFriend === 4) score -= 10;

                return score;
            }

            // --- è¼”åŠ©å‡½å¼ ---
            checkCaptures(r, c, opponent, boardState) {
                const captured = [];
                [[0,1], [0,-1], [1,0], [-1,0]].forEach(([dr, dc]) => {
                    const nr = r + dr, nc = c + dc;
                    if (this.isOnBoard(nr, nc) && boardState[nr][nc] === opponent) {
                        const group = this.getGroup(nr, nc, boardState);
                        if (group.liberties === 0) {
                            captured.push(...group.stones);
                        }
                    }
                });
                return captured;
            }

            getGroup(r, c, boardState) {
                const color = boardState[r][c];
                const stones = [];
                const visited = new Set();
                const queue = [{r, c}];
                const libertyPoints = new Set();
                visited.add(r + ',' + c);

                while (queue.length > 0) {
                    const curr = queue.pop();
                    stones.push(curr);
                    [[0,1], [0,-1], [1,0], [-1,0]].forEach(([dr, dc]) => {
                        const nr = curr.r + dr, nc = curr.c + dc;
                        if (this.isOnBoard(nr, nc)) {
                            const val = boardState[nr][nc];
                            if (val === 0) libertyPoints.add(nr + ',' + nc);
                            else if (val === color && !visited.has(nr + ',' + nc)) {
                                visited.add(nr + ',' + nc);
                                queue.push({r: nr, c: nc});
                            }
                        }
                    });
                }
                return { stones, liberties: libertyPoints.size };
            }

            getGroupLiberties(r, c, board) { return this.getGroup(r, c, board).liberties; }
            getGroupSize(r, c, board) { return this.getGroup(r, c, board).stones.length; }
            isOnBoard(r, c) { return r >= 0 && r < this.size && c >= 0 && c < this.size; }

            // --- UI æ›´æ–°èˆ‡åŠŸèƒ½ ---
            updateStatusUI() {
                // ä¸é‡ç¹ªæ£‹ç›¤ï¼Œåªæ›´æ–° class å’Œè³‡è¨Šï¼Œä¿æŒå‹•ç•«é †æš¢
                const cells = document.querySelectorAll('.intersection');
                cells.forEach(cell => {
                    const r = parseInt(cell.dataset.r);
                    const c = parseInt(cell.dataset.c);
                    const stone = cell.querySelector('.stone');
                    
                    if (stone) {
                        // æ›´æ–°æœ€å¾Œä¸€æ‰‹æ¨™è¨˜
                        if (this.lastMove && this.lastMove.r === r && this.lastMove.c === c) {
                            stone.classList.add('last-move');
                        } else {
                            stone.classList.remove('last-move');
                        }

                        // æ›´æ–°å«åƒç‹€æ…‹ (Atari)
                        if (this.atariPoints.has(`${r},${c}`)) {
                            stone.classList.add('atari');
                        } else {
                            stone.classList.remove('atari');
                        }
                        
                        // æ­»å­é¡¯ç¤º
                        if (this.gamePhase === 'scoring') {
                            if (this.deadStones.has(`${r},${c}`)) stone.classList.add('dead');
                            else stone.classList.remove('dead');
                        }
                    }
                });

                // æ›´æ–°é¢æ¿
                document.getElementById('card-black').classList.toggle('active', this.currentPlayer === 1 && this.gamePhase === 'playing');
                document.getElementById('card-white').classList.toggle('active', this.currentPlayer === 2 && this.gamePhase === 'playing');
                document.getElementById('cap-black').innerText = this.prisoners[1];
                document.getElementById('cap-white').innerText = this.prisoners[2];
                document.getElementById('info-black').innerText = "(ç©å®¶)";
                document.getElementById('info-white').innerText = this.aiEnabled ? "(AI)" : "(ç©å®¶)";
            }

            toggleAI() {
                this.aiEnabled = !this.aiEnabled;
                const btn = document.getElementById('btn-ai');
                if (this.aiEnabled) {
                    btn.className = "btn-ai";
                    btn.innerHTML = "<span>ğŸ¤– AI: é–‹å•Ÿ</span>";
                    // å¦‚æœç¾åœ¨è¼ªåˆ°ç™½æ£‹ï¼Œé–‹å•Ÿ AI å¾Œè¦ç«‹åˆ»è§¸ç™¼
                    if (this.currentPlayer === 2 && this.gamePhase === 'playing') {
                        setTimeout(() => this.aiMove(), 500);
                    }
                } else {
                    btn.className = "btn-ai off";
                    btn.innerHTML = "<span>ğŸ‘¤ AI: é—œé–‰</span>";
                }
                this.updateStatusUI();
            }

            pass() {
                if (this.gamePhase !== 'playing') return;
                this.passes++;
                this.showMessage(`ğŸ“¢ ${this.currentPlayer===1?'é»‘æ£‹':'ç™½æ£‹'} è™›æ‰‹`);
                this.currentPlayer = 3 - this.currentPlayer;
                this.lastMove = null;
                
                if (this.passes >= 2) {
                    this.enterScoring();
                } else {
                    this.updateStatusUI();
                    if (this.aiEnabled && this.currentPlayer === 2) {
                        setTimeout(() => this.aiMove(), 500);
                    }
                }
            }

            undo() {
                if (this.history.length === 0 || this.gamePhase !== 'playing' || this.isProcessing) return;
                
                // AI æ¨¡å¼æ‚”å…©æ­¥ï¼Œé›™äººæ¨¡å¼æ‚”ä¸€æ­¥
                let steps = (this.aiEnabled && this.currentPlayer === 1 && this.history.length >= 2) ? 2 : 1;
                
                for(let i=0; i<steps; i++){
                    const state = this.history.pop();
                    this.board = state.board;
                    this.prisoners = state.prisoners;
                    this.koPoint = state.ko;
                    this.currentPlayer = state.turn;
                    this.lastMove = state.lastMove;
                }
                
                this.atariPoints.clear();
                // æš´åŠ›é‡ç¹ªæ•´å€‹ç›¤é¢ä»¥ç¢ºä¿ç‹€æ…‹æ­£ç¢º
                this.fullRedraw();
                this.checkAtari(); 
                this.updateStatusUI();
            }

            fullRedraw() {
                const cells = document.querySelectorAll('.intersection');
                cells.forEach(cell => {
                    cell.innerHTML = '';
                    cell.classList.remove('has-stone');
                    // è£œå›æ˜Ÿä½
                    const r = parseInt(cell.dataset.r), c = parseInt(cell.dataset.c);
                    const stars = ['2,2', '6,2', '4,4', '2,6', '6,6'];
                    if (stars.includes(r + ',' + c)) {
                        const dot = document.createElement('div');
                        dot.className = 'star-dot';
                        cell.appendChild(dot);
                    }
                    // è£œå›æ£‹å­
                    const val = this.board[r][c];
                    if (val !== 0) {
                        const stone = document.createElement('div');
                        stone.className = `stone ${val===1?'black':'white'}`;
                        cell.appendChild(stone);
                        cell.classList.add('has-stone');
                    }
                });
            }

            showMessage(msg) {
                const el = document.getElementById('status-message');
                el.innerText = msg;
                el.style.opacity = 1;
                setTimeout(() => el.style.opacity = 0, 2000);
            }

            // --- çµ‚å±€ç›¸é—œ ---
            enterScoring() {
                this.gamePhase = 'scoring';
                this.showMessage("ğŸ çµ‚å±€ï¼è«‹é»æ“Šæ­»å­", true);
                document.getElementById('btn-pass').parentElement.style.display = 'none';
                document.getElementById('btn-ai').style.display = 'none';
                document.getElementById('btn-undo').style.display = 'none';
                document.getElementById('btn-calc').style.display = 'block';
                this.updateStatusUI();
                document.body.classList.add('scoring-mode');
            }

            toggleDeadStone(r, c) {
                if (this.board[r][c] === 0) return;
                const key = `${r},${c}`;
                if (this.deadStones.has(key)) this.deadStones.delete(key);
                else this.deadStones.add(key);
                this.updateStatusUI();
            }

            finishScoring() {
                // è¨ˆç®—é‚è¼¯
                const calcBoard = this.board.map(row => [...row]);
                let tempPrisoners1 = this.prisoners[1];
                let tempPrisoners2 = this.prisoners[2];

                this.deadStones.forEach(key => {
                    const [r, c] = key.split(',').map(Number);
                    if (calcBoard[r][c] === 1) tempPrisoners2++; // é»‘æ­»å­è®Šç™½ä¿˜è™œ
                    if (calcBoard[r][c] === 2) tempPrisoners1++; 
                    calcBoard[r][c] = 0;
                });

                // è¨ˆç®—åœ° (FloodFill)
                let blackArea = 0, whiteArea = 0;
                const visited = new Set();

                for(let r=0; r<this.size; r++) {
                    for(let c=0; c<this.size; c++) {
                        if (calcBoard[r][c] === 0 && !visited.has(`${r},${c}`)) {
                            const group = [];
                            const q = [{r,c}];
                            visited.add(`${r},${c}`);
                            let touchBlack = false, touchWhite = false;

                            while(q.length){
                                const curr = q.pop();
                                group.push(curr);
                                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc])=>{
                                    const nr=curr.r+dr, nc=curr.c+dc;
                                    if(this.isOnBoard(nr,nc)){
                                        const v = calcBoard[nr][nc];
                                        if (v===0 && !visited.has(`${nr},${nc}`)){
                                            visited.add(`${nr},${nc}`);
                                            q.push({r:nr, c:nc});
                                        } else if (v===1) touchBlack = true;
                                        else if (v===2) touchWhite = true;
                                    }
                                });
                            }

                            if (touchBlack && !touchWhite) {
                                blackArea += group.length;
                                this.drawTerritory(group, 'black');
                            } else if (!touchBlack && touchWhite) {
                                whiteArea += group.length;
                                this.drawTerritory(group, 'white');
                            }
                        }
                    }
                }

                const finalBlack = blackArea + tempPrisoners1;
                const finalWhite = whiteArea + tempPrisoners2 + this.komi;
                
                document.getElementById('final-black').innerText = finalBlack;
                document.getElementById('final-white').innerText = finalWhite;
                document.getElementById('winner-text').innerText = finalBlack > finalWhite ? "ğŸ† é»‘æ£‹ç²å‹" : "ğŸ† ç™½æ£‹ç²å‹";
                document.getElementById('result-modal').classList.add('active');
            }

            drawTerritory(points, color) {
                points.forEach(p => {
                    const cell = document.querySelector(`.intersection[data-r="${p.r}"][data-c="${p.c}"]`);
                    const t = document.createElement('div');
                    t.className = `territory ${color}`;
                    cell.appendChild(t);
                });
            }
        }

        let game = new GoGame();
    </script>
</body>
</html>