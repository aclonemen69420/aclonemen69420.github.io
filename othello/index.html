<!DOCTYPE html>
<html lang="zh-Hant-TW">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>1132934 -HW10</title>
    <style>
        :root {
            --board-size: 480px;
            --cell-size: calc(var(--board-size) / 8);
            --bg-color: #eef2f7;
            --board-color: #2e7d32;
            --cell-border: #1b5e20;
            --black-color: #1a1a1a;
            --white-color: #ffffff;
        }

        * { box-sizing: border-box; }

        body {
            font-family: "PingFang TC", "Noto Sans TC", "Microsoft JhengHei", -apple-system, sans-serif;
            background: var(--bg-color);
            color: #1f2937;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            perspective: 1000px;
        }

        .container {
            width: calc(var(--board-size) + 40px);
            padding: 20px;
            text-align: center;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
            background: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .status, .score { font-weight: 600; font-size: 1.1rem; }

        select, button {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #cbd5e1;
            background: #fff;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        button {
            background: #2563eb;
            color: white;
            border: none;
        }

        button:hover { background: #1d4ed8; transform: translateY(-1px); }

        .board-wrap {
            background: #235d26;
            padding: 12px;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2), inset 0 2px 5px rgba(255,255,255,0.1);
            display: inline-block;
        }

        .board {
            width: var(--board-size);
            height: var(--board-size);
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            background: var(--cell-border);
            border: 2px solid var(--cell-border);
        }

        .cell {
            position: relative;
            background: var(--board-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            overflow: visible;
        }

        .cell.available::after {
            content: "";
            width: 12px;
            height: 12px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            pointer-events: none;
        }

        .hint-num {
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 10px;
            color: rgba(255,255,255,0.5);
            font-weight: bold;
            pointer-events: none;
        }

        .piece-container {
            width: 85%;
            height: 85%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .piece-container.is-white { transform: rotateY(180deg); }
        .piece-container.is-black { transform: rotateY(0deg); }

        .piece-face {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            backface-visibility: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .face-black {
            background: radial-gradient(circle at 30% 30%, #444, #000);
            transform: rotateY(0deg);
        }

        .face-white {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            transform: rotateY(180deg);
        }

        .legend {
            margin-top: 20px;
            font-size: 0.9rem;
            color: #64748b;
        }

        #msgBox {
            position: fixed;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; padding: 24px 40px; border-radius: 16px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            display: none; z-index: 100; text-align: center;
        }
        #overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5); display: none; z-index: 99;
        }

        @media (max-width: 520px) {
            :root { --board-size: 340px; }
            .container { width: 100%; padding: 10px; }
        }
    </style>
</head>
<body>
    <div id="overlay"></div>
    <div id="msgBox">
        <h2 id="msgTitle">訊息</h2>
        <p id="msgText"></p>
        <button onclick="closeMsg(); initBoard();">再玩一局</button>
    </div>

    <main class="container">
        <h1>Othello</h1>
        
        <section class="controls">
            <div class="control-row">
                <div class="status">輪到：<span id="currentPlayer">黑</span></div>
                <div class="score">黑 <span id="blackScore">2</span> : <span id="whiteScore">2</span> 白</div>
            </div>
            <div class="control-row">
                <select id="gameMode">
                    <option value="pvp">雙人對戰</option>
                    <option value="pvc">對戰電腦 (你玩黑棋)</option>
                </select>
                <button id="restartBtn" onclick="initBoard()">重新開始</button>
            </div>
        </section>
        
        <section class="board-wrap">
            <div id="board" class="board"></div>
        </section>

        <section class="legend">
            <p>提示：圓點為可落子處，數字為可翻轉數量。</p>
        </section>
    </main>

    <script>
        const SIZE = 8;
        let board = [];
        let current = 1; // 1: black, 2: white
        let isAnimating = false;

        const boardEl = document.getElementById('board');
        const currentPlayerEl = document.getElementById('currentPlayer');
        const blackScoreEl = document.getElementById('blackScore');
        const whiteScoreEl = document.getElementById('whiteScore');
        const gameModeSelect = document.getElementById('gameMode');
        const msgBox = document.getElementById('msgBox');
        const msgText = document.getElementById('msgText');
        const overlay = document.getElementById('overlay');

        const DIRS = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];

        function closeMsg() {
            msgBox.style.display = 'none';
            overlay.style.display = 'none';
        }

        function createBoardDOM() {
            boardEl.innerHTML = '';
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${r}-${c}`;
                    boardEl.appendChild(cell);
                }
            }
        }

        function initBoard() {
            isAnimating = false;
            board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
            const m = SIZE / 2;
            board[m - 1][m - 1] = 2;
            board[m][m] = 2;
            board[m - 1][m] = 1;
            board[m][m - 1] = 1;
            current = 1;
            renderAll();
        }

        function within(r, c) { return r >= 0 && r < SIZE && c >= 0 && c < SIZE; }

        function flipsForMove(r, c, player) {
            if (board[r][c] !== 0) return [];
            const opponent = player === 1 ? 2 : 1;
            let allToFlip = [];

            for (const [dr, dc] of DIRS) {
                let rr = r + dr, cc = c + dc;
                let line = [];
                while (within(rr, cc) && board[rr][cc] === opponent) {
                    line.push({r: rr, c: cc});
                    rr += dr; cc += dc;
                }
                if (line.length > 0 && within(rr, cc) && board[rr][cc] === player) {
                    allToFlip = allToFlip.concat(line);
                }
            }
            return allToFlip;
        }

        function getLegalMoves(player) {
            const moves = new Map();
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const flips = flipsForMove(r, c, player);
                    if (flips.length > 0) moves.set(`${r},${c}`, flips);
                }
            }
            return moves;
        }

        function renderAll() {
            const moves = getLegalMoves(current);
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    updateCellUI(r, c, moves);
                }
            }
            updateScoreAndTurn();
        }

        function updateCellUI(r, c, moves) {
            const cell = document.getElementById(`cell-${r}-${c}`);
            const val = board[r][c];
            cell.innerHTML = '';
            cell.className = 'cell';
            cell.onclick = null;

            if (val !== 0) {
                const piece = createPieceDOM(val);
                cell.appendChild(piece);
            } else {
                const key = `${r},${c}`;
                if (moves && moves.has(key)) {
                    // 如果是電腦模式且輪到白棋，玩家不能點擊
                    const isComputerTurn = gameModeSelect.value === 'pvc' && current === 2;
                    if (!isComputerTurn) {
                        cell.classList.add('available');
                        const flips = moves.get(key);
                        const hint = document.createElement('div');
                        hint.className = 'hint-num';
                        hint.textContent = flips.length;
                        cell.appendChild(hint);
                        cell.onclick = () => handleMove(r, c, flips);
                    }
                }
            }
        }

        function createPieceDOM(val) {
            const container = document.createElement('div');
            container.className = `piece-container ${val === 1 ? 'is-black' : 'is-white'}`;
            const blackFace = document.createElement('div');
            blackFace.className = 'piece-face face-black';
            const whiteFace = document.createElement('div');
            whiteFace.className = 'piece-face face-white';
            container.appendChild(blackFace);
            container.appendChild(whiteFace);
            return container;
        }

        async function handleMove(r, c, flips) {
            if (isAnimating) return;
            isAnimating = true;

            board[r][c] = current;
            updateCellUI(r, c, null);

            const sortedFlips = flips.sort((a, b) => {
                const distA = Math.abs(a.r - r) + Math.abs(a.c - c);
                const distB = Math.abs(b.r - r) + Math.abs(b.c - c);
                return distA - distB;
            });

            for (const pos of sortedFlips) {
                await new Promise(res => setTimeout(res, 100));
                board[pos.r][pos.c] = current;
                const cell = document.getElementById(`cell-${pos.r}-${pos.c}`);
                const container = cell.querySelector('.piece-container');
                if (container) {
                    container.className = `piece-container ${current === 1 ? 'is-black' : 'is-white'}`;
                }
            }

            await new Promise(res => setTimeout(res, 400));

            current = current === 1 ? 2 : 1;
            let nextMoves = getLegalMoves(current);

            if (nextMoves.size === 0) {
                current = current === 1 ? 2 : 1;
                nextMoves = getLegalMoves(current);
                if (nextMoves.size === 0) {
                    endGame();
                    isAnimating = false;
                    return;
                } else {
                    showPassMsg();
                }
            }

            renderAll();
            isAnimating = false;

            // 如果是對戰電腦模式且輪到白棋
            if (gameModeSelect.value === 'pvc' && current === 2) {
                setTimeout(makeComputerMove, 1000);
            }
        }

        function makeComputerMove() {
            const moves = getLegalMoves(current);
            if (moves.size === 0) return;

            let bestMove = null;
            let maxFlips = -1;

            // 簡單 AI 策略：搶角落 > 翻轉最多
            const corners = ["0,0", "0,7", "7,0", "7,7"];
            for (let corner of corners) {
                if (moves.has(corner)) {
                    bestMove = corner;
                    break;
                }
            }

            if (!bestMove) {
                for (let [key, flips] of moves) {
                    if (flips.length > maxFlips) {
                        maxFlips = flips.length;
                        bestMove = key;
                    }
                }
            }

            const [r, c] = bestMove.split(',').map(Number);
            handleMove(r, c, moves.get(bestMove));
        }

        function updateScoreAndTurn() {
            let b = 0, w = 0;
            board.flat().forEach(v => {
                if (v === 1) b++;
                if (v === 2) w++;
            });
            blackScoreEl.textContent = b;
            whiteScoreEl.textContent = w;
            currentPlayerEl.textContent = current === 1 ? '黑' : '白';
            currentPlayerEl.style.color = current === 1 ? '#000' : '#2563eb';
        }

        function showPassMsg() {
            const passOverlay = document.createElement('div');
            passOverlay.style = "position:fixed; top:20%; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); color:white; padding:10px 20px; border-radius:20px; z-index:200;";
            passOverlay.textContent = `${current === 1 ? '白' : '黑'}方無處落子，跳過回合。`;
            document.body.appendChild(passOverlay);
            setTimeout(() => passOverlay.remove(), 2000);
        }

        function endGame() {
            const b = parseInt(blackScoreEl.textContent);
            const w = parseInt(whiteScoreEl.textContent);
            let winText = b > w ? "黑方獲勝！" : (w > b ? "白方獲勝！" : "雙方平手！");
            msgText.innerHTML = `最終比數<br>黑 ${b} : 白 ${w}<br><br><strong>${winText}</strong>`;
            msgBox.style.display = 'block';
            overlay.style.display = 'block';
        }

        createBoardDOM();
        initBoard();
    </script>
</body>
</html>
